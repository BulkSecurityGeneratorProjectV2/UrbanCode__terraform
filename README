
**************************************************
  _____ ___ ___ ___    _   ___ ___  ___ __  __ 
 |_   _| __| _ \ _ \  /_\ | __/ _ \| _ \  \/  |
   | | | _||   /   / / _ \| _| (_) |   / |\/| |
   |_| |___|_|_\_|_\/_/ \_\_| \___/|_|_\_|  |_|

**************************************************                                              


Installation Instructions
**************************************************

 Requirements:
   Java 1.6
   vmrun (only for VMware environments)
   Maven (for building/dependencies) 


    To use the VMware portion of Terraform, you will need to have access to
  a VCenter server.

    To use the Amazon Web Services portion of Terraform, you will need to have 
  an AWS Account with the EC2 services. This service is free, but see Amazon
  for limitations.
      (to get an AWS account: https://console.aws.amazon.com/console/home )

    Windows Azure with Terraform, is a wrapper around the Azure Node.js-based command line tool. 
    That tool depends on Node.js and npm, Node's package manager.
    Follow the installation instructions here:
    
    https://www.windowsazure.com/en-us/manage/linux/other-resources/command-line-tools/
    
    Since that command line tool is only available on Unix systems, Terraform with Azure cannot
    currently be run on Windows. Support for a wrapper around the Window's based Powershell
    commandlets may come in the future.


Building Terraform
======================================
  Set your current working directory to the extracted terraform directory.
  To build terraform, run:
     $ mvn package



Basic Installation
======================================
  You will find a shell script in terraform/bin. This is used
  to run Terraform. 

  To run terraform, use the provided terraform script for your operating system: 
    Unix
    ./terraform [command] [input-xml-file] [input-credentials-file] [prop1=val1 prop2=val2 ...]
    Windows
    terraform [command] [input-xml-file] [input-credentials-file] [prop1=val1 prop2=val2 ...]
    
    Allowed commands for all providers: create, destroy, suspend, resume
    Additional allowed commands for VMware: snapshot

  Amazon Web Services environments do not require any command line properties. 
  For more information on the AWS portion of Terraform, see the AWS section below.
  
  Windows Azure environments do not require any command line properties. 
  For more information on the Azure portion of Terraform, see the Microsoft section below.

  Starting a VMware environment requires specific command line properties. 
  See the VMware section below for more details.


Environment Templates
======================================
  Environment Template examples can be found in example-config/xml-templates

  A template is the structure of an environment, the blueprints. They are 
  formatted in xml and have a required structure to them. The root element of 
  every template must be <context> and must have an xmlns attribute. Underneath
  the <context> must be an <environment> element.
  What sits under the <environment> depends on the type of environment you want 
  to create. See each individual provider section below.

  Properties can be used in the XML template with ${property.name}. The 
  properties are passed in as arguments on the command line (anything after the
  3rd argument will be interpreted as a property). 
    e.g. if you set uDeploy.host=12.34.56.78 and uDeploy.port=7918, you can 
    then use these with 
      <param value="${uDeploy.host}"/> <param value="${uDeploy.host}"/>

  Some properties are defined by the provider. See each provider's section 
  below (VMware / AWS / Microsoft).


VMware
======================================

Allowed commands:

create - create an environment of VMs, optional networking, etc.
destroy - delete a previously created environment
suspend - suspend power on all VMs in the environment (the yellow "pause" icon in vCenter)
resume - resume all VMs in the environment (power them on)
snapshot - take a snapshot of all VMs in the environment.

  "create" takes in a template xml file. All other commands take in a generated instance xml file.

  Example "create" command line call to Terraform with a VMware template:

  ./terraform create vmware-template.xml vmware-1.key datacenter=my-datacenter
  host.name=my-host.mysite.com datastore=my-datastore 
  destination=path/to/my-destination/folder
  
  VMware vSphere instances require four properties to start, which are detailed
  later in the VMware section.
  
  To destroy an instance:
  
  Call terraform.sh with the following arguments:
  First argument: destroy
  Second argument: the xml instance file generated when you created your 
    instance (NOT the original template)
  Third argument: the credentials file
  
  No properties are required to destroy an instance.
  Example command line call to Terraform:
  
  terraform destroy terra-env-1234.xml vmware-credentials.key
  
  This will power down the VMs, delete them, delete the folder that Terraform
  created, and delete any virtual switches it created.
  
  Example commands for suspend, resume, and snapshot:
  
  terraform suspend terra-env-1234.xml vmware-credentials.key
  terraform resume terra-env-1234.xml vmware-credentials.key
  terraform snapshot terra-env-1234.xml vmware-credentials.key
  
  No properties are needed for any of these commands. The snapshot name will be the current
  date and time in YYYY-MM-DD hh:mm:ss format. (Example: 2012-08-15 10:01:45)

  -----------
  Templates
  -----------
  
  Below is a hierarchy of VMware elements in their templates. The number in
  parentheses represents how many of those elements are allowed.
  
        context(1)
        └── environment(1)
            ├── clone(n)
            │   ├── network-ref(n)
            │   ├── security-group-ref(n)
            │   ├── post-create-task(n)
            │   ├── event-listener(n)
            │   └── command(n)
            ├── network(n)
            └── security-group(n)
                └──port-range(n)
  
  All vmware templates must include one context element and one environment 
  element under the context:

  <context
  xmlns="org.urbancode.terraform.tasks.vmware">
      <environment 
      name="terra-env" 
      folder-name="terra-folder">
      </environment>
  </context>

  To add clones, insert "clone" elements in to the environment element. Clone
  elements look like this:
  
  <clone instance-name="instance-1"
            order="1"
            image-path="/mydatacenter/myimagefolder/linux-clone-image"
            snapshot-name="my-snapshot"
            count="1">
  </clone>
  
  Required attributes on a clone element: instance-name(string), 
  order(positive int), image-path(string), snapshot-name(string)
  Recommended attributes on a clone element:  user(string), password(string). 
  These specify the VM user name and password (which may need to be root, 
  depending on what configurations you are doing). The user and password
  attributes are required on any router clone, any clone with a command element,
  and any basically any clone with a post-create-task element.
  
  User and password should be a valid login on the VM.
  
  "count" is an optional attribute that specifies the number of clones to be 
  created. If no count attribute is specified it will default to "1". 
  
  The order attribute distinguishes the order VMs will be created - lowest to
  highest. If clones have the same number they are created in parallel. The 
  order in which parallel clones complete can be unpredictable.
  
  Terraform supports multiple different clone elements - useful if you want 
  them to have different name prefixes or orders in which they are created.
  
  You can add Unix shell commands to be executed once the VM is created using
  the "command" element. The command element has one attribute called "cmd" 
  which takes a shell command. You can also put a series of commands to be 
  executed separated by semicolons. Note that you should not use any 
  "shortcuts" in your commands; use fully qualified paths to programs.
  Example - use /home/username instead of ~, use /bin/sh instead of ./ or bash
  
  Examples:
  <command cmd="/bin/sleep 3" />
  <command cmd="/bin/sh /home/me/scripts/my-shell-script" />
  Mount a network drive to /mnt/test
  <command cmd="/bin/mkdir /mnt/test;/bin/mount -t nfs 
    nas.myhost.net:/volumes/public /mnt/test"/>
  
  For creating a private network, include a network element in the environment 
  for each subnet.
  
  <network network-name="my-net-web" port-count="32"/>
  
  A network element must have a network-name(string) and a port-count(int). 
  This creates a virtual switch and port group.
  
  There is an optional parameter vlan-id for a network to specify the port 
  group VLAN ID. By default it is 0, which represents no VLAN.
  
  Example: <network network-name="my-net-web" port-count="32" vlan-id="2096" />
  
  All clones on the private network must have a network-ref element pertaining 
  to the proper network, referenced by name.
  
  <network-ref network-name="my-net-web" nic-index="1"/>
  
  The name should be the same as the network name they are on. The nic-index 
  corresponds to the network card which will be attached to the network.
  
  A general note about networking - there must be some way for your VMs to have
  access to a physical NIC in order for them to get an IP. There are two ways 
  to do this. One is for your image to have a NIC attached that is on an 
  internet-connected virtual switch (that is, a vSwitch with a physical NIC 
  attached).
  The second way is for the VM to be connected to a private network serviced by 
  a router.
  The router must have one NIC attached to a vSwitch with a physical NIC and a 
  NIC attached to the vSwitch that your VMs are on.
  
  If you are creating a router to use for the private network, and you want Terraform to manage
  the networking for your environment, you must use a Linux image that can act as a router. 
  We recommend a Debian or Ubuntu distribution.
  
  You must also include these elements on the router clone:
  <post-create-task/>
  <event-listener/>
  
  These elements will configure the networking files on the router. It is 
  highly recommended that the router be created BEFORE any clones that are on 
  its network (specify using the order attribute).
  In addition, for any non-router clone on the router, add this attribute: 
  assign-host-ip="true" . 
  This will tell the clone to get its IP from the router instead of from your 
  DHCP service.
  
  By default, on a private network, all incoming traffic to ports on the 
  network are blocked. You can open ports by adding a security group element 
  to the environment.
  
  <security-group name="default-group">
      <port-range first-port="22" last-port="22"/>
      <port-range first-port="80" last-port="80"/>
      <port-range first-port="3306" last-port="3306"/>
      <port-range first-port="8080" last-port="9090"/>
  </security-group>
  
  This security group will open ports 22, 80, 3306, and 8080-9090 on any 
  instance that references this security group. To reference a security group 
  on a clone, add this element to the clone:
  
  <security-group-ref name="default-group"/>
  
  The name should be equal to the security group name. This feature only works 
  if you have a router in your template.
  
  Finally, an example template with a private network, an application server, 
  and a database server:
  
  <?xml version="1.0" encoding="UTF-8"?>
  <context
  xmlns="org.urbancode.terraform.tasks.vmware">
      <environment 
      name="terra-env" 
      folder-name="terra-folder">
          
          <network network-name="my-net-web" port-count="32"/>
          <security-group name="default-group">
              <port-range first-port="22" last-port="22"/>
              <port-range first-port="80" last-port="80"/>
              <port-range first-port="3306" last-port="3306"/>
              <port-range first-port="8080" last-port="9090"/>
          </security-group>
      
          <clone instance-name="router-1"
                    order="1"
                    image-path="/mydatacenter/myimagefolder/router-image"
                    snapshot-name="my-snapshot"
                    user="root"
                    password="mypassword">
              <network-ref network-name="my-net-web" nic-index="1"/>
              <post-create-task/>
              <event-listener/>
          </clone>
                    
          <clone instance-name="app-instance-1"
                    order="2"
                    image-path="/mydatacenter/myimagefolder/linux-clone-image"
                    snapshot-name="my-snapshot"
                    assign-host-ip="true"
                    count="1">
              <security-group-ref name="default-group"/>
              <network-ref network-name="my-net-web" nic-index="0"/>
          </clone>
          
          <clone instance-name="db-instance-1"
                    order="2"
                    image-path="/mydatacenter/myimagefolder/linux-clone-image"
                    snapshot-name="my-snapshot"
                    assign-host-ip="true"
                    count="1">
              <security-group-ref name="default-group"/>
              <network-ref network-name="my-net-web" nic-index="0"/>
          </clone>
          
      </environment>
  </context>
  
  ----------------------
  Chef Post-Create Tasks
  ----------------------
  Terraform now supports a post create task for running a Chef cookbook with Chef Solo.
  The name of the element is: <chef:post-create-task>. It goes inside a clone element.
  You must have this namespace in your context element:
  
    xmlns:chef="org.urbancode.terraform.tasks.vmware.chef"
    
  So for example, your opening context tag might look like this:
    
    <context
    xmlns="org.urbancode.terraform.tasks.vmware"
    xmlns:chef="org.urbancode.terraform.tasks.vmware.chef">
  
  This task will:
    1. check if Chef is installed, and if not, install it
    2. attempt to create the directories /etc/chef, /var/chef, /var/chef/data_bags if they do
      not exist yet
    3. Copy the configuration files solo.rb, node.json, and the json configuration file to the VM
    4. run a cookbook located at an Internet repository via URL, or one pre-baked on your VM's
      file system
    5. the output of the process is logged to /var/chef/chef.out on the guest VM
    
    There are several relevant configuration files needed to run this post-create task. All of them
    should be placed in your conf directory.
    
    chef-install.sh - this is the install script for Chef that gets copied over. It's not
    recommended that you mess with this as it comes straight from Opscode.
    
    The following files will be specified by name on your xml template and can be renamed so you can
    store many different versions of them:
    
    solo.rb - the chef-solo configuration file
    node.json - the chef configuration file if the VM is a node
    chef.json - the json configuration file which gets passed in via the -j argument to chef-solo
    
    This is what the task element should look like in your xml file (with appropriate file names):
    
     <chef:post-create-task cookbook-url="http://example-repo.com/cookbooks/mybook.tar.gz"
     solo-rb-file="solo.rb" node-json-file="node.json" json-conf-file="chef.json"/>
     
  The cookbook-url attribute is required, but it could be a file path instead.
  The file attributes are not required, but if they are not specified, they will default to
  "solo.rb", "node.json", and "chef.json" respectively.
  
  So for example, say you want a node named foo with the configuration file node-foo.json.
  And you also want a node named bar on a different VM that has the conf file node-bar.json.
  Say they also had different run lists, specified on their conf files, foo.json and bar.json.
  But you might want the same solo.rb file because that is standard across your system.
  
  Your xml might look like this:
  
    <clone instance-name="vm1"
                  order="1"
                  image-path="/datacenter/images/ubuntu-image"
                  snapshot-name="initial-snapshot"
                  poweredOn="true"
                  user="root"
                  password="password">
            <command cmd="/usr/bin/apt-get update"/>
            <chef:post-create-task cookbook-url="http://repo.com/cookbook1.tar.gz" 
            solo-rb-file="solo.rb" node-json-file="node-foo.json" json-conf-file="foo.json"/>
    </clone>
    <clone instance-name="vm2"
                  order="2"
                  image-path="/datacenter/images/ubuntu-image"
                  snapshot-name="initial-snapshot"
                  poweredOn="true"
                  user="root"
                  password="password">
            <command cmd="/usr/bin/apt-get update"/>
            <chef:post-create-task cookbook-url="http://repo.com/cookbook2.tar.gz" 
            solo-rb-file="solo.rb" node-json-file="node-bar.json" json-conf-file="bar.json"/>
    </clone>
  
  A few caveats:
  
  For now, this must be run as root.
  
  It is recommended that you run a command to update your package manager repos beforehand.
  If your cookbook calls apt-get, often you will get an error message saying that
  "apt-get exited with code 100" if you did not update apt-get recently.
  For example, for a Ubuntu VM, inside your clone element and before your chef task, put this:
  
    <command cmd="/usr/bin/apt-get update"/>

  -----------
  Credentials
  -----------
  A credentials file is a text file ending in a .key suffix. It contains 
  name=value pairs separated by lines.

  Example file - creds-example.key
  Contents:

  type=org.urbancode.terraform.credentials.vmware.CredentialsVmware
  name=my.vmware.creds
  username=my-vcenter-user
  password=my-vcenter-password
  url=https://vcenter.mysite.com/sdk
  
  For vmware, the "type", "name", "username", "password", and "url" properties 
  are all mandatory.
  The "name" property whatever you want to name your credentials. The name should be unique and
  should not contain spaces.
  Username is your vCenter login name.
  Password is your vCenter password.
  Url is the url pointing to your vCenter server, followed by a /sdk suffix. HTTPS is recommended.
  
  Vmware environments have 4 required properties when creating an environment. 
  EC2 environments have none.
  Here are the four required properties for vmware that must be passed in the 
  command line arguments:

  datacenter=my-datacenter
  host.name=my-host.mysite.com
  destination=path/to/my-destination/folder
  datastore=my-datastore

  These correspond to the vSphere datacenter name, the name of the host the VMs 
  will be created on, the destination folder for the environment folder, and 
  the datastore for the VMs.


Amazon Web Services 
======================================

Allowed commands:

create - create an environment of instances, optional VPCs, load balancers, etc.

destroy - delete a previously created environment

suspend - "stop" all instances in the environment. NOTE - there are many differences between this
and the "suspend" command for VMware. You won't be billed for instance usage, but you will be billed
for your EBS volume. Amazon actually will deprovision your VM and save your associated EBS.
When you restart a stopped instance, it will have a new IP address, DNS name, etc.

resume - start all stopped instances in the environment.


  -----------
  Credentials
  -----------
  You will need to create a credentials file with information from
  your Amazon Web Services account. There is a template file in 
  example-config/credentials-templates/aws.creds.template.key
  
  You will need to replace the access.key and secret.key with the
  access key and secret key associated with your AWS account. You
  can find this information at : 
        https://portal.aws.amazon.com/gp/aws/securityCredentials
  access.key = Access Key ID
  secret.key = Secret Access Key

  -----------
  Templates
  -----------
    The general layout of an AWS Environment Template is the following:
    The number in the parenthesis is the number of those elements allowed.
      context(1)
        └── environment(1)
            ├── instance(n)
            │   ├── boot-actions(1)
            │   │   └── script(n)
            │   │       └── param(n)
            │   ├── post-create-actions(1)
            │   │   └── ssh(n)
            │   └── security-group-ref(n)
            ├── load-balancer(n)
            │   ├── health-check(1)
            │   └── listener(n)
            └── vpc(1)
                ├── inet-gwy(1)
                ├── route-table(n)
                │   └── route(n)
                ├── subnet(n)
                └── vpc-security-group(n)
                    └── rule(n)


    The following is a list of elements available in the xml:
	[ The hierarchy represents which elements go under which in the xml ]

    o context: The context holds the whole environment. It has one or more 
      xmlns attributes, which specify map an xml namespace to a package. The 
      packages it points to should contain a properties file named:
        terralib.classes 
	      for VMware use: xmlns="com.urbancode.uprovision.tasks.vmware"
	      for AWS use: xmlns="com.urbancode.uprovision.tasks.aws"

      o environment: The environment contains the Virtual Private Cloud (only 1 
        VPC per environment). The name of the environment is used as a prefix 
        on the name tags in AWS.

        o vpc: This is the core network. It is made with a CIDR (x.x.x.x/y). 
          For more information on CIDR notation, see: 
      	http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing

          o subnet: Subnets are smaller networks inside of the VPC. They each 
            have their own CIDR which is a sub-set of the VPC's CDIR. Each 
            subnet has a zone property which specifies a region that the subnet
            will be located in. If any instances in this subnet need to be
            behind an Elastic Load Balancer, the zone of this subnet must match 
            that of the load balancer.
      
          o inet-gwy: The Internet Gateway attaches to a VPC and allows 
            internet access from inside the VPC.

          o route-table: Each VPC has a "Main" route table that cannot be 
            deleted. Route Tables can be associated with a single subnet 
            subnet. There can only be one "default" Route Table, which all new
            subnets will use if no Route Table is specified. The default Route 
            Table will attempt to make a Route to allow instances to reach the
            internet if an Internet Gateway exists. 	    

            o route: Routes are elements of a Route Table. They contain a 
              target, which can be an Internet Gateway, a NAT (a specially 
              configured instance), or an ENI (Elastic Network Interface). They 
              also contain a destination, which is described by a CIDR block. 

	      * For more information on Route Tables and Routes, see: 
	http://docs.amazonwebservices.com/AmazonVPC/latest/UserGuide/VPC_Routing.html        


          o vpc-security-group: A Security Group essentially acts as a firewall.
            They can be applied to multiple instances (and/or load balancers) 
            and allow or disallow incoming or outgoing traffic on specified 
            ports. A Security Group contains a collection of Rules, which 
            contain the details on the traffic rules. They also have a name and 
            description.

            o rule: A Rule contains a source, which will apply to rule to just 
              traffic from the specified CIDR. A Rule also contains a protocol, 
              which the rule will apply only to traffic using that protocol, a 
              port range, which is the range of ports the rule will apply to, 
              and an inbound flag, which if set to false, will apply the rule 
              to outbound traffic. 

        o instance: The representation of the EC2 instance that will be 
          launched.
          -name: the name of the instance. The number of the instance will be 
           automatically appended to the end of the instance name once it has 
           been launched. 
	     e.g. an instance with the name "web" and count "2" will launch instances:
                  web00 and web01
          -ami-id: the id of of the Amazon Machine Image to use for the instance
          -subnet-name: the name of the subnet to launch the instance into
          -count: the number of instances with these same details you would like
           to launch
          -elastic-ip: a flag that if set to true, will assign an Elastic Ip 
            Address to this instance. This allows you to reach the instance 
            from outside of the VPC.
             * AWS has a default of 5 EIPs per account. For more info, see: 
	       http://aws.amazon.com/contact-us/eip_limit_request/
          -private-key-ref: The Key Pair (SSH key) that the instance will be 
           accessable by. You can find these in your AWS account. This is also 
           the key that will be used to run the SSH Post Create Actions.
          -image-size: The size, or type, of the instance you want to create. 
           VPCs currently cannot support instances of size t1.micro.
             valid values: m1.small, c1.medium, m1.medium, m1.large, m1.xlarge, 
             m2.xlarge, m2.2xlarge, m2.4xlarge, c1.xlarge
             For more info, see: 
	     http://aws.amazon.com/ec2/instance-types/
	  -kernel-id: This is the id of the kernel you would like to use. It is 
     recommended that you leave this empty, as it will use the default kernel 
     for the AMI.
	  -ramdisk-id: This is the id of the RAM disk you would like to use. It is 
     recommended that you leave this empty, as it will use the default RAM disk 
     for the AMI.
          -load-balancer: the name of the load balancer the instance will be 
           registered with
          -priority: This is the order in which the instance will be launched 
           in. The instances with the lowest priority will be completely 
           launched first. This means that the instance will hit the 'running' 
           state, the 'ok' status, all boot-actions will be ran, then the 
           post-create-actions will be ran. You can have multiple instances 
           with the same priority and they will all be launched at once.

          o security-group-ref: This is just a reference to the Security Group 
            you would like to apply to the instance. You can have multiple of 
            these.
    
          o boot-actions: This is a list of actions that will be run at 
            FIRST BOOT of the instance. These actions are run as root and are 
            referered to as User-Data by Amazon. This will automatically 
            convert the script to Base64 as required by Amazon. The whole 
            user-data script (but not including the contents of external 
            scripts) will be resolved for any properties that may show up. 
            Script can be 16KB max.
            -shell: This is the shell that the user-data will be run with.

            o script: This is a action that will grab a script from the given 
              URL and run it with the specified shell. This grabs the script 
              using 'wget'. You can have multiple script elements.

              o param: These are parameters for a given script. They will be 
                ran in order from first to last defined. 
    
          o post-create-actions: This contains all the actions to be ran after 
            the instance has fully started.

            o ssh: Connects to an instance via ssh. The instance should have an
              Elastic Ip, allowing outside traffic in, along with allowing 
              inbound traffic on port 22. 
		* include any used key-pair files (.pem) in ~/.terraform/

        o load-balancer: An Elastic Load Balancer by Amazon for load balancing 
          instances.
            -name: the name of the load balancer. 
            -subnet-name: the subnet to associate with the load balancer
            -app-cookie-name: the name of the cookie your application uses. 
             You can leave this blank if you want the load balancer to handle 
             the cookies.

          o listener: Where and how the load balancer listens
               -protocol: Valid values: http, https, tcp, ssh
               -instance-port: The port on the instance to send traffic to
               -load-balancer-port: Port to listen on
               -cert-id: Use only if you are using a secure protocol

          o health-check: This is how the load balancer determines whether or 
            not an instance is health and can accept traffic or not. The 
            instance must return a status 200 OK in order to be considered a 
            successful check.
              -interval: the frequency of checks on instances
              -timeout: how long before a check on the instance will timeout
              -unhealthy-count: How many consecutive checks before an instance 
               is determined to be unhealthy
              -healthy-count: How many consecuctive checks before an instance 
               is determined to be healthy
              -protocol: the protocol on which to check the instance
              -port: the port to check the instance on
              -path: the path on the instance to check

* For more information on any of these elements, check the Amazon Web Services
documentation at: http://aws.amazon.com/documentation/ec2/

  -----------
  Other Notes
  -----------
	
	When an instance is launched, two properties are set. One for 
     the public ip address, and one for the private ip address. These
     can be used with ${INSTANCENAME.public.ip} ${INSTANCENAME.private.ip}
     e.g. If you launch an instance with name "web" and count "2", you can
       access the ips of the two instances with these properties:
         ${web00.private.ip} ${web01.public.ip} etc
     Note: a public ip address (aka Elastic IP) will only be assigned if 
       the elastic-ip flag on an instance is set to true.


	Check the example AWS template in the example-config/xml-templates
     for more information on creating templates.

	In order for any Post Create Actions to run on an Amazon EC2 
     instance, the instance must have an Elastic Ip Address assigned 
     to it. You must also have the key-pair (ssh key) that the instance 
     was created with in your ~/.terraform directory. 
	The Elastic Ip Address is neccessary since the instances are 
     launched inside of a Virtual Private Cloud. The EIP allows you to 
     communicate with those instances from outside of the VPC.
     File Information
	The key-pair file is needed for connecting to the server. You
     must also know what user that key-pair was associated with. This is 
     determined when the AMI (Amazon Machine Image) is created. 

    IMPORTANT: Launching public images without a key pair ID will leave 
    them inaccessible. The public key material is made available to the 
    instance at boot time by placing it in the openssh_id.pub file on a 
    logical device that is exposed to the instance as /dev/sda2 (the 
    ephemeral store). The format of this file is suitable for use as an 
    entry within ~/.ssh/authorized_keys (the OpenSSH format). This can 
    be done at boot (e.g., as part of rc.local) allowing for secure 
    access without passwords. Optional user data can be provided in the 
    launch request. All instances that collectively comprise the launch 
    request have access to this data For more information, see Instance 
    Metadata.

    NOTE: If any of the AMIs have a product code attached for which the 
    user has not subscribed, the instance launch will fail.


Microsoft (Windows Azure)
======================================

Allowed commands:

create - creates an environment of VMs, websites, cloud services, storage, etc.

destroy - deletes a previously created environment

  -----------
  Credentials
  -----------
  Because your Azure credentials are handled by the Azure for Node command line tool, inputting real
  credentials is unnecessary. However, to satisfy the Terraform parser, you must have a credentials
  file with dummy contents. A credentials file has 4 components: type, name, username, and password.
  Your credentials file must have this format, but the property values for name, username, and
  password can be anything.
  
  type=org.urbancode.terraform.credentials.microsoft.CredentialsMicrosoft
  name=my.azure.creds
  username=asdf
  password=jkl

  -----------
  Templates
  -----------
  The general layout of an Azure Environment Template is the following:
  The number in the parenthesis is the number of those elements allowed.
      context(1)
        └── environment(1)
            ├── vm(n)
            │  └──endpoint(n)
            │   └──attach-disk(n)
            └── website(n)
            
        The following is a list of elements available in the xml:
    
    [ The hierarchy represents which elements go under which in the xml ]

    o context: The context holds the whole environment. It has one or more 
      xmlns attributes, which specify map an xml namespace to a package. The 
      packages it points to should contain a properties file named:
        terralib.classes 
          for Azure use: xmlns="com.urbancode.uprovision.tasks.microsoft"

      o environment: The environment contains VMs and websites.

        o vm: This is an Azure virtual machine. Required attributes: vm-name, image, username,
        password, location or affinity-group. Type "azure vm" for more help.
        
        Lots of optional attributes are available, and they roughly correspond to the optional
        flags for creating VMs, which you can find by typing "azure vm create -h".
        
        List of optional attributes: blob-url, vm-size (default small), ssh (boolean),
        rdp(boolean), virtual-network-name (Windows VMs only right now), subnet-names,
        add-uuid (makes VM name unique)
        
          o endpoint: adds an endpoint to a VM. Required attributes: public-port, private-port
          
          o disk-attach: attaches a disk to a VM. Required attribute: disk-name
        
        o website: This is an Azure website. Required attributes: host-name, location
        Optional attribute: git(boolean) - will create a git repo on the site if true
        
  For more information, simply type "azure" in your command line (if you have azure installed).


Conf File Information
======================================

 [  Global  ]


 * log4j.properties
  Located in the $TERRAFORM_HOME/conf folder.
  This file contains the properties used to configure logging. 
 
 
 [   AWS    ]
 
 
 [  VMware  ]
 
  * ippool.conf
  Located in the $TERRAFORM_HOME/conf folder.
  Contains the start and end points for the IP pool used by vCenter.
  The start is the begining IP address to start allocating for VMs.
  It should be in the following format:
   start=192.168.2.1
   end=192.168.2.250
   
  The files below are created in the $TERRAFORM_HOME/temp folder and deleted 
  when the environment is deleted.
 
 * .temp files - these are the beginning forms of the conf files listed below. 
   Content is added to them and placed in the appropriate conf file.
 
 The following files are packaged with Terraform for use with VMWare.
 
 * dhcpd.conf
 This is the standard DHCPD configuration file for dhcpd, the Internet Systems 
 Consortium DHCP Server.
 
 See http://linux.die.net/man/5/dhcpd.conf
 
 * interfaces
 This is a debian/ubuntu networking configuration file for the interfaces on 
 the router machine.
 
 See http://support.arpnetworks.com/kb/vps/example-etcnetworkinterfaces-for-debian-and-ubuntu
 
 * iptables.conf
 
 This is the standard iptables configuration file for configuring a firewall 
 and allowable network traffic.
 
 See http://linux.die.net/man/8/iptables
 
 * isc-dhcp-server
 
 This file indicates which network interfaces will be serving up DHCP 
 addresses. It is typically located in /etc/default and referenced by 
 /etc/init.d/isc-dhcp-server .
 The only required content of this file is one line, as below
 INTERFACES="eth1 eth2"
 Quotation marks included. All network interfaces to be served DHCP addresses 
 should be listed, separated by one space.
  
======================================

